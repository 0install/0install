#!/usr/bin/env python
import os, sys
from optparse import OptionParser

from zeroinstall.injector import reader, model, basedir
from zeroinstall import support, alias, helpers

def export(name, value):
	"""Try to guess the command to set an environment variable."""
	shell = os.environ.get('SHELL', '?')
	if 'csh' in shell:
		return "setenv %s %s" % (name, value)
	return "export %s=%s" % (name, value)

for first_path in os.environ['PATH'].split(':'):
	if os.path.realpath(first_path).startswith(basedir.xdg_cache_home):
		pass # print "Skipping cache", first_path
	elif not os.access(first_path, os.W_OK):
		pass # print "No access", first_path
	else:
		break
else:
	print >>sys.stderr, ("No writable non-cache directory in $PATH, which currently contains:\n\n%s\n"
		"To create a directory for your scripts, use these commands:\n"
		"$ mkdir ~/bin\n"
		"$ %s" % ('\n'.join(os.environ['PATH'].split(':')), export('PATH', '$HOME/bin:$PATH')))
	sys.exit(1)

parser = OptionParser(usage="usage: %%prog [options] alias [interface [command]]\n\n"
		"Creates a script in the first usable directory in $PATH\n"
		"(%s) to run 'interface'.\n"
		"If no interface is given, edits the policy for an existing alias.\n"
		"For interfaces providing more than one command, the desired command\n"
		"may also be given." % first_path)
parser.add_option("-m", "--manpage", help="show the manual page for an existing alias", action='store_true')
parser.add_option("-r", "--resolve", help="show the URI for an alias", action='store_true')
parser.add_option("-V", "--version", help="display version information", action='store_true')
parser.disable_interspersed_args()

(options, args) = parser.parse_args()

if options.version:
	import zeroinstall
	print "0alias (zero-install) " + zeroinstall.version
	print "Copyright (C) 2007 Thomas Leonard"
	print "This program comes with ABSOLUTELY NO WARRANTY,"
	print "to the extent permitted by law."
	print "You may redistribute copies of this program"
	print "under the terms of the GNU Lesser General Public License."
	print "For more information about these matters, see the file named COPYING."
	sys.exit(0)

if options.manpage:
	if len(args) != 1:
		os.execlp('man', 'man', *args)
		sys.exit(1)

if len(args) < 1 or len(args) > 3:
	parser.print_help()
	sys.exit(1)
alias_prog, interface_uri, main = (list(args) + [None, None])[:3]

if options.resolve or options.manpage:
	if interface_uri is not None:
		parser.print_help()
		sys.exit(1)

if interface_uri is None:
	try:
		if not os.path.isabs(alias_prog):
			full_path = support.find_in_path(alias_prog)
			if not full_path:
				raise alias.NotAnAliasScript("Not found in $PATH: " + alias_prog)
		else:
			full_path = alias_prog

		interface_uri, main = alias.parse_script(full_path)
	except alias.NotAnAliasScript, ex:
		if options.manpage:
			os.execlp('man', 'man', *args)
		print >>sys.stderr, str(ex)
		sys.exit(1)

interface_uri = model.canonical_iface_uri(interface_uri)

if options.resolve:
	print interface_uri
	sys.exit(0)

if options.manpage:
	sels = helpers.ensure_cached(interface_uri)
	if not sels:
		# Cancelled by user
		sys.exit(1)

	selected_impl = sels.selections[interface_uri]
	if selected_impl.id.startswith('/'):
		impl_path = selected_impl.id
	else:
		from zeroinstall.injector.iface_cache import iface_cache
		impl_path = iface_cache.stores.lookup(selected_impl.id)

	if main is None:
		main = selected_impl.main
		if main is None:
			print >>sys.stderr, "No main program for interface '%s'" % interface_uri
			sys.exit(1)

	# TODO: the feed should say where the man-page is, but for now we'll just search
	# the whole implementation for one

	prog_name = os.path.basename(main)
	alias_name = os.path.basename(args[0])

	assert impl_path
	manpages = []
	for root, dirs, files in os.walk(impl_path):
		for f in files:
			if f.endswith('.gz'):
				manpage_file = f[:-3]
			else:
				manpage_file = f
			if manpage_file.endswith('.1') or \
			   manpage_file.endswith('.6') or \
			   manpage_file.endswith('.8'):
			   	manpage_prog = manpage_file[:-2]
				if manpage_prog == prog_name or manpage_prog == alias_name:
					os.execlp('man', 'man', os.path.join(root, f))
					sys.exit(1)
				else:
					manpages.append((root, f))

	print "No matching manpage was found for '%s' (%s)" % (alias_name, interface_uri)
	if manpages:
		print "These non-matching man-pages were found, however:"
		for root, file in manpages:
			print os.path.join(root, file)
	sys.exit(1)

if len(args) == 1:
	os.execlp('0launch', '0launch', '-gd', '--', interface_uri)
	sys.exit(1)

try:
	interface = model.Interface(interface_uri)
	if not reader.update_from_cache(interface):
		print >>sys.stderr, "Interface '%s' not currently in cache. Fetching..." % interface_uri
		if os.spawnlp(os.P_WAIT, '0launch', '0launch', '-d', interface_uri):
			raise model.SafeException("0launch failed")
		if not reader.update_from_cache(interface):
			raise model.SafeException("Interface still not in cache. Aborting.")

	script = os.path.join(first_path, alias_prog)
	if os.path.exists(script):
		raise model.SafeException("File '%s' already exists. Delete it first." % script)
		sys.exit(1)
except model.SafeException, ex:
	print >>sys.stderr, ex
	sys.exit(1)

wrapper = file(script, 'w')
alias.write_script(wrapper, interface_uri, main)

# Make new script executable
os.chmod(script, 0111 | os.fstat(wrapper.fileno()).st_mode)
wrapper.close()

print "Created script '%s'." % script
print "To edit policy: 0alias %s" % alias_prog
print "(note: some shells require you to type 'rehash' now)"
