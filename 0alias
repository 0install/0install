#!/usr/bin/env python
import os, sys
from optparse import OptionParser

from zeroinstall.injector import reader, model, basedir
from zeroinstall import support, alias, helpers

def export(name, value):
	"""Try to guess the command to set an environment variable."""
	shell = os.environ.get('SHELL', '?')
	if 'csh' in shell:
		return "setenv %s %s" % (name, value)
	return "export %s=%s" % (name, value)

for first_path in os.environ['PATH'].split(':'):
	if os.path.realpath(first_path).startswith(basedir.xdg_cache_home):
		pass # print "Skipping cache", first_path
	elif not os.access(first_path, os.W_OK):
		pass # print "No access", first_path
	else:
		break
else:
	print >>sys.stderr, ("No writable non-cache directory in $PATH, which currently contains:\n\n%s\n"
		"To create a directory for your scripts, use these commands:\n"
		"$ mkdir ~/bin\n"
		"$ %s" % ('\n'.join(os.environ['PATH'].split(':')), export('PATH', '$HOME/bin:$PATH')))
	sys.exit(1)

parser = OptionParser(usage="usage: %%prog [options] alias interface [command]\n\n"
		"Creates a script in the first usable directory in $PATH\n"
		"(%s) to run 'interface'.\n"
		"For interfaces providing more than one command, the desired command\n"
		"may also be given." % first_path)
parser.add_option("-V", "--version", help="display version information", action='store_true')
parser.add_option("-m", "--manpage", help="show the manual page for an existing alias", action='store_true')
parser.disable_interspersed_args()

(options, args) = parser.parse_args()

if options.version:
	import zeroinstall
	print "0alias (zero-install) " + zeroinstall.version
	print "Copyright (C) 2007 Thomas Leonard"
	print "This program comes with ABSOLUTELY NO WARRANTY,"
	print "to the extent permitted by law."
	print "You may redistribute copies of this program"
	print "under the terms of the GNU Lesser General Public License."
	print "For more information about these matters, see the file named COPYING."
	sys.exit(0)

if options.manpage:
	if len(args) != 1:
		os.execlp('man', 'man', *args)
		sys.exit(1)
	prog = args[0]
	if not os.path.isabs(prog):
		full_path = support.find_in_path(prog)
		if not full_path:
			os.execlp('man', 'man', *args)
			sys.exit(1)
	else:
		full_path = prog

	try:
		uri, main = alias.parse_script(full_path)
	except alias.NotAnAliasScript, ex:
		os.execlp('man', 'man', *args)
		sys.exit(1)

	sels = helpers.ensure_cached(uri)
	if not sels:
		# Cancelled by user
		sys.exit(1)

	selected_impl = sels.selections[uri]
	if selected_impl.id.startswith('/'):
		impl_path = selected_impl.id
	else:
		from zeroinstall.injector.iface_cache import iface_cache
		impl_path = iface_cache.stores.lookup(selected_impl.id)

	if main is None:
		main = selected_impl.main
		if main is None:
			print >>sys.stderr, "No main program for interface '%s'" % uri
			sys.exit(1)

	# TODO: the feed should say where the man-page is, but for now we'll just search
	# the whole implementation for one

	prog_name = os.path.basename(main)
	alias_name = os.path.basename(prog)

	assert impl_path
	manpages = []
	for root, dirs, files in os.walk(impl_path):
		for f in files:
			if f.endswith('.1') or \
			   f.endswith('.6') or \
			   f.endswith('.8'):
			   	manpage_prog = f[:-2]
				if manpage_prog == prog_name or manpage_prog == alias_name:
					os.execlp('man', 'man', os.path.join(root, f))
					sys.exit(1)
				else:
					manpages.append((root, f))

	print "No matching manpage was found for '%s' (%s)" % (alias_name, uri)
	if manpages:
		print "These non-matching man-pages were found, however:"
		for root, file in manpages:
			print os.path.join(root, file)
	sys.exit(1)

if len(args) < 2 or len(args) > 3:
	parser.print_help()
	sys.exit(1)

alias_prog, interface_uri = args[:2]
if len(args) == 3:
	main = args[2]
else:
	main = None

try:
	interface_uri = model.canonical_iface_uri(interface_uri)

	interface = model.Interface(interface_uri)
	if not reader.update_from_cache(interface):
		print >>sys.stderr, "Interface '%s' not currently in cache. Fetching..." % interface_uri
		if os.spawnlp(os.P_WAIT, '0launch', '0launch', '-d', interface_uri):
			raise model.SafeException("0launch failed")
		if not reader.update_from_cache(interface):
			raise model.SafeException("Interface still not in cache. Aborting.")

	script = os.path.join(first_path, alias_prog)
	if os.path.exists(script):
		raise model.SafeException("File '%s' already exists. Delete it first." % script)
		sys.exit(1)
except model.SafeException, ex:
	print >>sys.stderr, ex
	sys.exit(1)

wrapper = file(script, 'w')
alias.write_script(wrapper, interface_uri, main)

# Make new script executable
os.chmod(script, 0111 | os.fstat(wrapper.fileno()).st_mode)
wrapper.close()

print "Created script '%s'." % script
print "To edit policy: %s --versions" % alias_prog
print "(note: some shells require you to type 'rehash' now)"
