#!/usr/bin/env python
import os, sys
import shutil
from optparse import OptionParser

from zeroinstall.injector import model, download, gpg
from zeroinstall.injector import policy, download, gpg, run

parser = OptionParser(usage="usage: %prog [options] interface [args]\n"
			    "       %prog --list [search-term]")
parser.add_option("-g", "--gui", help="show graphical policy editor", action='store_true')
parser.add_option("-l", "--list", help="list all known interfaces", action='store_true')
parser.add_option("-r", "--refresh", help="refresh all used interfaces", action='store_true')
parser.add_option("-v", "--version", help="display version information", action='store_true')
parser.disable_interspersed_args()

(options, args) = parser.parse_args()

if options.list:
	if len(args) == 0:
		match = None
	elif len(args) == 1:
		match = args[0].lower()
	else:
		parser.print_help()
		sys.exit(1)
	from zeroinstall.injector import reader
	for i in reader.list_all_interfaces():
		if match and match not in i.lower(): continue
		print i
	sys.exit(0)

if options.version:
	import zeroinstall
	print "0launch (zero-install) " + zeroinstall.version
	print "Copyright (C) 2005 Thomas Leonard"
	print "This program comes with ABSOLUTELY NO WARRANTY,"
	print "to the extent permitted by law."
	print "You may redistribute copies of this program"
	print "under the terms of the GNU General Public License."
	print "For more information about these matters, see the file named COPYING."
	sys.exit(0)

if len(args) < 1:
	parser.print_help()
	sys.exit(1)

if options.gui:
	interface_uri = 'http://0install.net/2005/interfaces/injector-gui'
	prog_args = args[:]
else:
	interface_uri = args[0]
	prog_args = args[1:]

if not interface_uri.startswith('http:'):
	interface_uri = os.path.realpath(interface_uri)	# For testing

class AutoPolicy(policy.Policy):
	monitored_downloads = None

	def __init__(self, interface_uri):
		policy.Policy.__init__(self, interface_uri)
		self.monitored_downloads = []

	def monitor_download(self, dl):
		error_stream = dl.start()
		self.monitored_downloads.append((error_stream, dl))

	def start_downloading_impls(self):
		for iface, impl in self.get_uncached_implementations():
			if not impl.download_sources:
				raise model.SafeException("Implementation " + impl.id + " of "
					"interface " + iface.get_name() + " cannot be "
					"downloaded (no download locations given in "
					"interface!")
			dl = download.begin_impl_download(impl.download_sources[0])
			self.monitor_download(dl)

# Singleton instance used everywhere...
auto_policy = AutoPolicy(interface_uri)
auto_policy.recalculate()

if options.refresh:
	for x in auto_policy.walk_interfaces():
		auto_policy.begin_iface_download(x, False)

def wait_for_downloads():
	while auto_policy.monitored_downloads:
		print "Currently downloading:"
		for e, dl in auto_policy.monitored_downloads:
			print "- " + dl.url

		for e, dl in auto_policy.monitored_downloads[:]:
			errors =  e.read()
			if errors:
				dl.error_stream_data(errors)
				continue
			e.close()
			auto_policy.monitored_downloads.remove((e, dl))
			data = dl.error_stream_closed()
			if isinstance(dl, download.InterfaceDownload):
				auto_policy.check_signed_data(dl, data)
			elif isinstance(dl, download.ImplementationDownload):
				auto_policy.add_to_cache(dl.source, data)
			else:
				raise Exception("Unknown download type %s" % dl)

def execute():
	auto_policy.start_downloading_impls()

	wait_for_downloads()
		
	run.execute(auto_policy, prog_args)

# Get interfaces...
try:
	wait_for_downloads()
except model.SafeException, ex:
	print >>sys.stderr, ex
	sys.exit(1)

try:
	execute()
except model.SafeException, ex:
	if auto_policy.network_use != model.network_full:
		print >>sys.stderr, "Error. Retrying with network use = full"
		auto_policy.network_use = model.network_full	
		auto_policy.recalculate()
		try:
			execute()
		except model.SafeException, ex:
			print >>sys.stderr, ex
	else:
		print >>sys.stderr, ex
